
--------------------------------
---- TABLES AND Types
DROP TABLE IF EXISTS logs CASCADE;
DROP TYPE IF EXISTS log;

CREATE TYPE log AS (
    log_id int, -- primary key
    user_name varchar(50),
    description text,
    log_ts timestamptz
);
CREATE TABLE logs OF log (
    CONSTRAINT logs_log_id PRIMARY KEY (log_id),
    CONSTRAINT logs_log_ts CHECK(log_ts IS NOT NULL)
);
ALTER TYPE log ADD ATTRIBUTE x varchar(10) CASCADE;

SELECT * FROM logs;

-------------------
---- Tables and constraints

DROP TABLE IF EXISTS logs CASCADE;
DROP TABLE IF EXISTS users CASCADE;

CREATE TABLE users (
    user_id serial primary key,
    name text
);

CREATE TABLE logs (
    log_id serial PRIMARY KEY, -- primary key
    -- log_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id int,
    description text,
    log_ts timestamp with time zone NOT NULL DEFAULT current_timestamp -- not null, default value
);

-- foreign key
--Unlike for primary key and unique constraints, PostgreSQL doesn’t automatically
--create an index for foreign key constraints; you should add this yourself to speed
--up queries.

ALTER TABLE logs ADD CONSTRAINT logs_user_id FOREIGN KEY (user_id) REFERENCES users (user_id);

-- unique constraints
ALTER TABLE logs ADD CONSTRAINT logs_unique_user_logts UNIQUE (user_id,log_ts);
-- check constraints
ALTER TABLE logs ADD CONSTRAINT logs_description_len CHECK (length(description)> 50);


--- exclusion constraints 

CREATE TABLE schedules(id serial primary key, room int, time_slot tstzrange);
ALTER TABLE schedules ADD CONSTRAINT 
    ex_schedules EXCLUDE USING gist (room WITH =, time_slot WITH &&);


-----------------
--- identity and serial
ALTER TABLE logs ALTER COLUMN log_id RESTART WITH 2000; -- change sequence number

--- identity vs serial 
--The main benefit of the IDENTITY construct is that an identity is always tied to a specific table, so
--incrementing and resetting the value is managed with the table. A serial, on the other
--hand, creates a sequence object that may or may not be reused by other tables and
--needs to be dropped manually when it’s no longer needed.

-----------------------------------------------
--- PARTITIONED TABLES
- When partitions are used, data can be inserted into the core table and is rerouted
automatically to the matching partition.
-The parent of the partition can’t have primary keys, unique keys, or indexes, although the child partitions can. 
- the parent partitioned table can’t have any rows of its own. 


DROP TABLE IF EXISTS logs CASCADE;

CREATE TABLE logs (
    log_id int GENERATED BY DEFAULT AS IDENTITY,
    user_name varchar(50),
    description text,
    log_ts timestamp with time zone NOT NULL DEFAULT current_timestamp
) PARTITION BY RANGE (log_ts);

CREATE TABLE logs_2011 PARTITION OF logs FOR VALUES FROM ('2011-1-1') TO ('2012-1-1') ;
CREATE INDEX logs_2011_log_ts ON logs_2011 USING btree(log_ts);
ALTER TABLE logs_2011 ADD CONSTRAINT logs_2011_log_id PRIMARY KEY (log_id)

INSERT INTO logs(user_name, description ) VALUES ('regina', 'Sleeping');
-- ERROR: no partition of relation "logs" found for row

CREATE TABLE logs_gt_2011 PARTITION OF logs FOR VALUES FROM ('2012-1-1') TO (maxvalue);

-- Seq Scan on public.logs_gt_2011
EXPLAIN (ANALYZE, VERBOSE) 
SELECT * FROM logs WHERE log_ts > '2017-05-01';


---------------------------
--- UNLOGGED tables
These tables will not be part of any write-ahead logs. The big advantage
of an unlogged table is that writing data to it is much faster than to a logged table 10−15 times faster  

--TEMP vs unlogged tables
The only difference is that temporary tables are cached in process private memory, governed by the temp_buffers parameter, while unlogged tables are cached in shared_buffers.
So the size of these parameters will affect the performance.